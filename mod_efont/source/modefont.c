/*
 * This file was generated by micropython-extmod-generator
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2023 dotnfc
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

// Include required definitions first.
#include <stdio.h>
#include <string.h>
#include "py/obj.h"
#include "py/objstr.h"
#include "py/runtime.h"
#include "py/builtin.h"
#include "py/binary.h"

#include "ff2_mpy.h"
#include "modefont.h"
#include "image_mpy.h"

#define EFONT_DMSG(...)   // mp_printf(&mp_plat_print, "[efm] " __VA_ARGS__)

// class FT2(object):
typedef struct _mp_obj_FT2_t
{
    mp_obj_base_t base;
    ff2_handler hff2;

    mp_obj_t hfont; // font file handle within hff2

    uint16_t size;
    bool mono;
    bool bold;
    bool italic;
} mp_obj_FT2_t;

STATIC const mp_obj_type_t mod_efont_FT2_type;

// def FT2.__init__(self_in, file: str, draw, size: int=16, mono: bool=False, bold: bool=False, italic: bool=False) -> bool
//@brief Load font from file(.ttf, .pcf)
//@param file, file to load
//@param draw, draw pixel routine
//@param size, default size to draw text
//@param mono, load as mono font for EPD
//@param bold, bold style to draw text
//@param italic, italic style to draw text
//@return True if font was loaded
STATIC mp_obj_t mod_efont_FT2_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args_in)
{
    void *hFont;

    const char *font_file = mp_obj_str_get_str(args_in[0]);
    hFont = ff2_mpy_loadFont(font_file, NULL);
    if (hFont == NULL)
    {
        return mp_const_none;
    }

    mp_map_t kw_args;
    mp_map_init_fixed_table(&kw_args, n_kw, args_in + n_args);

    enum
    {
        ARG_render,
        ARG_size,
        ARG_mono,
        ARG_bold,
        ARG_italic
    };
    static const mp_arg_t allowed_args[] = {
        {MP_QSTR_render, MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_obj = mp_const_none}},
        {MP_QSTR_size, MP_ARG_INT, {.u_int = 16}},
        {MP_QSTR_mono, MP_ARG_BOOL, {.u_bool = false}},
        {MP_QSTR_bold, MP_ARG_BOOL, {.u_bool = false}},
        {MP_QSTR_italic, MP_ARG_BOOL, {.u_bool = false}},
    };

    /* exclude 'font_file' */
    n_args -= 1;
    const mp_obj_t *pos_args = args_in + 1;

    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
    mp_arg_parse_all(n_args, pos_args, &kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);

    mp_obj_FT2_t *self = mp_obj_malloc(mp_obj_FT2_t, type);
    self->hff2 = hFont;
    self->hfont = ff2_mpy_get_mp_file_obj(hFont);
    self->size = (uint16_t)(args[ARG_size].u_int & 0xfff);
    self->mono = args[ARG_mono].u_bool;
    self->bold = args[ARG_bold].u_bool;
    self->italic = args[ARG_italic].u_bool;

    EFONT_DMSG("new %s => %p, font_obj = %p\n", font_file, self->hff2, self->hfont);

    // a render with method setPixel(x, y, c) routine, aka framebuf
    mp_obj_t render = mp_const_none;
    mp_obj_t render_pixel;

    if (args[ARG_render].u_obj != MP_OBJ_NULL)
    {
        render = args[ARG_render].u_obj;
        if (render)
        {
            mp_obj_t fb_pixel_fn = mp_load_attr(render, MP_QSTR_pixel);
            if (fb_pixel_fn)
            {
                render_pixel = fb_pixel_fn;
            }
            else
            {
                MP_RAISE_ERROR("fb.pixel() function required.");
            }
        }
    }

    if (render == mp_const_none)
    {
        MP_RAISE_ERROR("fb.pixel() function required.");
    }
    else
    {
        ff2_mpy_setRender(hFont, render, render_pixel);
    }

    ff2_mpy_setSize(hFont, self->size);
    ff2_mpy_setBold(hFont, self->bold);
    ff2_mpy_setMono(hFont, self->mono);
    ff2_mpy_setItalic(hFont, self->italic);

    return MP_OBJ_FROM_PTR(self);
}

STATIC void mod_efont_FT2_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) 
{
    (void)kind;
    mp_printf(print, "<FT2 => %p>", MP_OBJ_TO_PTR(self_in));
}

// def FT2.drawString(self_in, x: int, y: int, w: int=-1, h: int=-1, align: int=0, text: str='') -> int
//@brief draw text string
//@param x, x coordinate of text drawing box
//@param y, y coordinate of text drawing box
//@param w, width of text drawing box
//@param h, height  of text drawing box
//@param align, alignment of text, ALIGN_LEFT, ALIGN_CENTER, ALIGN_RIGHT
//@param text, text to draw
//@return next x coordinate after drawing
STATIC mp_obj_t mod_efont_FT2_drawString(size_t n_args, const mp_obj_t *args_in)
{
    mp_obj_FT2_t *self = MP_OBJ_TO_PTR(args_in[0]);

    mp_int_t x = mp_obj_get_int(args_in[1]);
    mp_int_t y = mp_obj_get_int(args_in[2]);
    mp_int_t w = mp_obj_get_int(args_in[3]);
    // mp_int_t h = mp_obj_get_int(args_in[4]);
    mp_int_t align = mp_obj_get_int(args_in[5]);
    const char *text = mp_obj_str_get_str(args_in[6]);

    if (n_args > 7)
    {
        self->size = mp_obj_get_int(args_in[7]);
        ff2_mpy_setSize(self->hff2, self->size);
    }

    EFONT_DMSG("draw %p, font_obj = %p\n", self->hff2, self->hfont);
    ff2_mpy_reset_mp_file_obj(self->hff2, self->hfont);

    // GET_STR_DATA_LEN(text, str, str_len);
    //  mp_print_str(MPY_PLAT_PRNT, text);
    uint16_t nx = 0;
    if (align == EFONT_ALIGN_LEFT)
    {
    }
    else if (align == EFONT_ALIGN_CENTER)
    {
        nx = ff2_mpy_getTextWidth(self->hff2, text);
        if (nx < w)
        {
            x += (w - nx) / 2;
        }
    }
    else if (align == EFONT_ALIGN_RIGHT)
    {
        nx = ff2_mpy_getTextWidth(self->hff2, text);
        if (nx < w)
        {
            x += w - nx;
        }
    }
    else
    {
        MP_RAISE_ERROR("unsupported alignment");
    }

    nx = ff2_mpy_drawString(self->hff2, text, x, y, false);

    return mp_obj_new_int(nx);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_efont_FT2_drawString_obj, 3, 8, mod_efont_FT2_drawString);

// def FT2.getStringWidth(self_in, text: str) -> int
//@brief get text width when drawing
//@param text, text for measurement
//@return text width
STATIC mp_obj_t mod_efont_FT2_getStringWidth(mp_obj_t self_in, mp_obj_t text)
{
    mp_obj_FT2_t *self = MP_OBJ_TO_PTR(self_in);

    return mp_obj_new_int(self->size);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_2(mod_efont_FT2_getStringWidth_obj, mod_efont_FT2_getStringWidth);

// def FT2.setSize(self_in, size: int)
//@briefset font size to draw
//@param size, to modify
STATIC mp_obj_t mod_efont_FT2_setSize(mp_obj_t self_in, mp_obj_t size)
{
    mp_obj_FT2_t *self = MP_OBJ_TO_PTR(self_in);

    self->size = mp_obj_get_int(size);
    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_2(mod_efont_FT2_setSize_obj, mod_efont_FT2_setSize);

// def FT2.unload(self)
//@Unload font and free resources
//
STATIC mp_obj_t mod_efont_FT2_unload(mp_obj_t self_in)
{
    mp_obj_FT2_t *self = MP_OBJ_TO_PTR(self_in);
    ff2_mpy_unloadFont(self->hff2);

    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(mod_efont_FT2_unload_obj, mod_efont_FT2_unload);

// def FT2.getFile(self)
//@Unload font and free resources
//
STATIC mp_obj_t mod_efont_FT2_getFile(mp_obj_t self_in)
{
    mp_obj_FT2_t *self = MP_OBJ_TO_PTR(self_in);

    return MP_OBJ_FROM_PTR(self->hfont);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(mod_efont_FT2_getFile_obj, mod_efont_FT2_getFile);

// FT2 attr mono
STATIC mp_obj_t mod_efont_FT2_attr_mono(mp_obj_t self_in, mp_obj_t dest, mp_obj_t attr)
{
    mp_obj_FT2_t *self = MP_OBJ_TO_PTR(self_in);

    if (dest == MP_OBJ_NULL)
    {
        // load attribute
        dest = mp_obj_new_bool(self->mono);
    }
    else
    {
        // store attribute
        self->mono = mp_obj_is_true(attr);
        ff2_mpy_setMono(self->hff2, self->mono);
        dest = MP_OBJ_NULL; // as success
    }

    return dest;
}

// FT2 attr bold
STATIC mp_obj_t mod_efont_FT2_attr_bold(mp_obj_t self_in, mp_obj_t dest, mp_obj_t attr)
{
    mp_obj_FT2_t *self = MP_OBJ_TO_PTR(self_in);

    if (dest == MP_OBJ_NULL)
    {
        // load attribute
        dest = mp_obj_new_bool(self->bold);
    }
    else
    {
        // store attribute
        self->bold = mp_obj_is_true(attr);
        ff2_mpy_setBold(self->hff2, self->bold);
        dest = MP_OBJ_NULL; // as success
    }

    return dest;
}

// FT2 attr italic
STATIC mp_obj_t mod_efont_FT2_attr_italic(mp_obj_t self_in, mp_obj_t dest, mp_obj_t attr)
{
    mp_obj_FT2_t *self = MP_OBJ_TO_PTR(self_in);

    if (dest == MP_OBJ_NULL)
    {
        // load attribute
        dest = mp_obj_new_bool(self->italic);
    }
    else
    {
        // store attribute
        self->italic = mp_obj_is_true(attr);
        ff2_mpy_setItalic(self->hff2, self->italic);
        dest = MP_OBJ_NULL; // as success
    }
    return dest;
}

// FT2 attr size
STATIC mp_obj_t mod_efont_FT2_attr_size(mp_obj_t self_in, mp_obj_t dest, mp_obj_t attr)
{
    mp_obj_FT2_t *self = MP_OBJ_TO_PTR(self_in);

    if (dest == MP_OBJ_NULL)
    {
        // load attribute
        dest = mp_obj_new_int(self->size);
    }
    else
    {
        // store attribute
        self->size = mp_obj_get_int(attr);
        ff2_mpy_setSize(self->hff2, self->size);
        dest = MP_OBJ_NULL; // as success
    }
    return dest;
}

STATIC void mod_efont_FT2_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{

    if ((dest[0] != MP_OBJ_NULL) && (dest[1] == MP_OBJ_NULL))
    {
        // delete attribute, just return
        return;
    }

    switch (attr)
    {
    case MP_QSTR_mono:
        dest[0] = mod_efont_FT2_attr_mono(self_in, dest[0], dest[1]);
        break;
    case MP_QSTR_bold:
        dest[0] = mod_efont_FT2_attr_bold(self_in, dest[0], dest[1]);
        break;
    case MP_QSTR_italic:
        dest[0] = mod_efont_FT2_attr_italic(self_in, dest[0], dest[1]);
        break;
    case MP_QSTR_size:
        dest[0] = mod_efont_FT2_attr_size(self_in, dest[0], dest[1]);
        break;
    default:
        dest[1] = MP_OBJ_SENTINEL; // Attribute not found
        break;
    }
}

// FT2 class stuff
STATIC const mp_rom_map_elem_t mod_efont_FT2_locals_dict_table[] = {    
    // method
    {MP_ROM_QSTR(MP_QSTR_drawString), MP_ROM_PTR(&mod_efont_FT2_drawString_obj)},
    {MP_ROM_QSTR(MP_QSTR_getStringWidth), MP_ROM_PTR(&mod_efont_FT2_getStringWidth_obj)},
    {MP_ROM_QSTR(MP_QSTR_setSize), MP_ROM_PTR(&mod_efont_FT2_setSize_obj)},
    {MP_ROM_QSTR(MP_QSTR_unload), MP_ROM_PTR(&mod_efont_FT2_unload_obj)},
    {MP_ROM_QSTR(MP_QSTR_getFile), MP_ROM_PTR(&mod_efont_FT2_getFile_obj)},
};
STATIC MP_DEFINE_CONST_DICT(mod_efont_FT2_locals_dict, mod_efont_FT2_locals_dict_table);

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mod_efont_FT2_type,
    MP_QSTR_FT2,
    MP_TYPE_FLAG_NONE,
    make_new, mod_efont_FT2_make_new,
    attr, mod_efont_FT2_attr,
    print, mod_efont_FT2_print,
    locals_dict, &mod_efont_FT2_locals_dict);


///////////////////////////////////////////////////////////////////////////////////////
// class Image(object):
typedef struct _mp_obj_Image_t
{
    mp_obj_base_t base;

    bool mono; // mono for EPD

    mp_fun_var_t fbuf_pixel; // fbuf pixel function
    void *hima;              // image context
    int8_t ima_type;         // image type
    uint16_t ima_w, ima_h;   // image width, height
    uint16_t fbuf_w, fbuf_h; // framebuf width, height in pixels
} mp_obj_Image_t;

// def Image.__init__(self_in, SCN_W, SCN_H)
// 'ima = Image(epd.WIDTH, epd.HEIGHT)'
STATIC mp_obj_t mod_efont_Image_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args_in)
{

    mp_obj_Image_t *self = mp_obj_malloc(mp_obj_Image_t, type);

    if (n_args != 2)
    {
        MP_RAISE_ERROR("screen width and height must be set");
    }

    self->ima_w = 0;
    self->ima_h = 0;

    self->fbuf_w = mp_obj_get_int(args_in[0]);
    self->fbuf_h = mp_obj_get_int(args_in[1]);

    return MP_OBJ_FROM_PTR(self);
}

// def Image.draw(self_in, buf, x: int=0, y: int=0, w: int=-1, h: int=-1, unload: bool=True)
//@brief Draw image in buffer (x, y)
//@param fbuf, desting fbuf object
//@param x, y, left-top pos to draw
//@param r, b, right-bottom to draw
//@param unload, free image resource after draw
//@return True done, False failed
STATIC mp_obj_t mod_efont_Image_draw(size_t n_args, const mp_obj_t *args_in)
{

    mp_obj_Image_t *self = MP_OBJ_TO_PTR(args_in[0]);

    if (self->hima == NULL)
    {
        mp_obj_new_bool(false);
    }

    if (n_args < 4)
    {
        MP_RAISE_ERROR("more parameters required");
    }

    void *dest_fbuf = args_in[1];
    uint16_t left = mp_obj_get_int(args_in[2]);
    uint16_t top = mp_obj_get_int(args_in[3]);

    int32_t right = -1, bottom = -1;
    if (n_args >= 5)
    {
        right = mp_obj_get_int(args_in[4]);
    }

    if (n_args >= 6)
    {
        bottom = mp_obj_get_int(args_in[5]);
    }

    bool unload = true; // free resources after drawing
    if (n_args == 7)
    {
        unload = mp_obj_is_bool(args_in[6]);
    }

    // check the canvas rect cropping
    bool cropping = false;
    if (right <= 0 || bottom <= 0)
    { // user not specify the r & b, => screen rigth & bottom
        right = self->fbuf_w - 1;
        bottom = self->fbuf_h - 1;
    }

    if ((left + self->ima_w) > right)
    {
        cropping = true; // image is larger than canvas` right
    }

    if ((top + self->ima_h) > bottom)
    {
        cropping = true; // image is larger than canvas` bottom
    }

    bool ret = image_mpy_draw(self->hima, self->ima_type, cropping, dest_fbuf, left, top, right, bottom);

    if (unload)
    {
        image_mpy_unload(self->hima, self->ima_type);
        self->hima = NULL;
    }
    return mp_obj_new_bool(ret);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_efont_Image_draw_obj, 1, 6, mod_efont_Image_draw);

// def Image.load(self_in, file: str, mono: bool=False)
//@brief Load image from file(.png, .jpg)
//@param file, file to load
//@param mono, load as mono image for EPD
//@return (width, height) if image was loaded, otherwise None
STATIC mp_obj_t mod_efont_Image_load(size_t n_args, const mp_obj_t *args_in)
{
    mp_obj_Image_t *self = MP_OBJ_TO_PTR(args_in[0]);

    self->mono = false;
    const char *font_file = mp_obj_str_get_str(args_in[1]);
    if (n_args >= 3)
    {
        self->mono = mp_obj_is_true(args_in[2]);
    }

    self->hima = image_mpy_load(font_file, &self->ima_w, &self->ima_h, &self->ima_type);
    if (self->hima == NULL)
    {
        MP_RAISE_ERROR("failed to load image");
    }
    image_mpy_set_fbuf_info(self->hima, self->ima_type, self->fbuf_w, self->fbuf_h);

    // return mp_obj_new_tuple(2, (mp_obj_t []) { mp_obj_new_int(w), mp_obj_new_int(h) });
    return mp_obj_new_bool(true);
}
STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mod_efont_Image_load_obj, 2, 3, mod_efont_Image_load);

// def Image.unload(self_in)
//@brief Unload image, free image resource
STATIC mp_obj_t mod_efont_Image_unload(mp_obj_t self_in)
{
    mp_obj_Image_t *self = MP_OBJ_TO_PTR(self_in);

    if (self->hima == NULL)
    {
        MP_RAISE_ERROR("image not loaded");
    }

    image_mpy_unload(self->hima, self->ima_type);
    self->hima = NULL;
    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(mod_efont_Image_unload_obj, mod_efont_Image_unload);

// Image attr width
STATIC mp_obj_t mod_efont_Image_attr_width(mp_obj_t self_in, mp_obj_t dest, mp_obj_t attr)
{
    mp_obj_Image_t *self = MP_OBJ_TO_PTR(self_in);

    if (dest == MP_OBJ_NULL)
    {
        // load attribute
        dest = mp_obj_new_int(self->ima_w);
    }
    else
    {
        // store attribute
    }
    return dest;
}

// Image attr height
STATIC mp_obj_t mod_efont_Image_attr_height(mp_obj_t self_in, mp_obj_t dest, mp_obj_t attr)
{
    mp_obj_Image_t *self = MP_OBJ_TO_PTR(self_in);

    if (dest == MP_OBJ_NULL)
    {
        // load attribute
        dest = mp_obj_new_int(self->ima_h);
    }
    else
    {
        // store attribute
    }
    return dest;
}

// Image class attr
STATIC void mod_efont_Image_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{

    if ((dest[0] != MP_OBJ_NULL) && (dest[1] == MP_OBJ_NULL))
    {
        // delete attribute, just return
        return;
    }

    switch (attr)
    {
    case MP_QSTR_width:
        dest[0] = mod_efont_Image_attr_width(self_in, dest[0], dest[1]);
        break;
    case MP_QSTR_height:
        dest[0] = mod_efont_Image_attr_height(self_in, dest[0], dest[1]);
        break;
    default:
        dest[1] = MP_OBJ_SENTINEL; // Attribute not found
        break;
    }
}

// Image class stuff
STATIC const mp_obj_type_t mod_efont_Image_type;

STATIC const mp_rom_map_elem_t mod_efont_Image_locals_dict_table[] = {
    {MP_ROM_QSTR(MP_QSTR_draw), MP_ROM_PTR(&mod_efont_Image_draw_obj)},
    {MP_ROM_QSTR(MP_QSTR_load), MP_ROM_PTR(&mod_efont_Image_load_obj)},
    {MP_ROM_QSTR(MP_QSTR_unload), MP_ROM_PTR(&mod_efont_Image_unload_obj)},
};
STATIC MP_DEFINE_CONST_DICT(mod_efont_Image_locals_dict, mod_efont_Image_locals_dict_table);

STATIC MP_DEFINE_CONST_OBJ_TYPE(
    mod_efont_Image_type,
    MP_QSTR_Image,
    MP_TYPE_FLAG_NONE,
    make_new, mod_efont_Image_make_new,
    attr, mod_efont_Image_attr,
    locals_dict, &mod_efont_Image_locals_dict
);


// module stuff
STATIC mp_obj_t efont_package___init___(void) 
{
    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_0(efont_package___init___obj, efont_package___init___);

STATIC const mp_rom_map_elem_t mp_module_efont_globals_table[] = {
    {MP_ROM_QSTR(MP_QSTR___name__),     MP_ROM_QSTR(MP_QSTR__efont)},
    {MP_ROM_QSTR(MP_QSTR___init__),     MP_ROM_PTR(&efont_package___init___obj) },
    {MP_ROM_QSTR(MP_QSTR_FT2),          MP_ROM_PTR(&mod_efont_FT2_type)},
    {MP_ROM_QSTR(MP_QSTR_Image),        MP_ROM_PTR(&mod_efont_Image_type)},

    // font alitment 
    {MP_ROM_QSTR(MP_QSTR_ALIGN_CENTER), MP_ROM_INT(EFONT_ALIGN_CENTER)},
    {MP_ROM_QSTR(MP_QSTR_ALIGN_LEFT),   MP_ROM_INT(EFONT_ALIGN_LEFT)},
    {MP_ROM_QSTR(MP_QSTR_ALIGN_RIGHT),  MP_ROM_INT(EFONT_ALIGN_RIGHT)},
};
STATIC MP_DEFINE_CONST_DICT(mp_module_efont_globals, mp_module_efont_globals_table);

const mp_obj_module_t mp_module_efont = {
    .base = {&mp_type_module},
    .globals = (mp_obj_dict_t *)&mp_module_efont_globals,
};

MP_REGISTER_MODULE(MP_QSTR_efont, mp_module_efont);
